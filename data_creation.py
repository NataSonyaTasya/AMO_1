# -*- coding: utf-8 -*-
"""(data_creation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Ji_4f-xPpIwu-RyE-RCuzl2uFOG7plh
"""

import numpy as np
import pandas as pd

import os  
os.makedirs('test', exist_ok=True) 
os.makedirs('train', exist_ok=True)

def lenfile(path):
    count = len([f for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))])
    return count

# Задаем данные
def true_fun(x, a=np.pi, b = 0, f=np.sin): 
    """Генерация произвольной зависимости   
    Входные переменные:
    ===========
    x: массив данных из которых будет генерироваться зависимость
    a: коэффициент на который входные данные будут умножаться
    если а - список, то это коэффициенты в полиномиальной зависимости
    так, а = [1,2,3] позволит сгенерировать зависимость вида 1*x+ 2*x^2 +3*x^3 
    b: коэффициент который будет добавлен к данным (постоянная прибавочка)
    f: функция которая будет применена к зависимости. Можно задать списком. Тогда это будут разные колонки
    """
    x = np.atleast_1d(x)[:] # убеждаемся что данные - одномерный массив
    a = np.atleast_1d(a)
    
    if f is None: f = lambda x:x # если функция не задана (None) то ничего не происходит
    x = np.sum([ai*np.power(x, i+1) for i,ai in enumerate(a)],axis=0) # домнажаем входные данные на коэффициенты (и если надо возводим в степень)

    return f(x+ b)

def noises(shape , noise_power):
    """Генерация случайного шума   
    Входные переменные:
    ===========
    shape: размерность массива данных
    noise_power: коэффициент ~ сила шума
    """
    return np.random.randn(*shape) *noise_power # библиотека numpy может генерировать случайные числа. 
                                                # в данном случае - нормальное распределение (среднее = 0, стандартное отклонение = 1 )

def dataset(a, b, f = None,  N = 250, x_max =1, noise_power = 0, random_x = True,  seed = 42):
    """Генерация набора данных   
    Входные переменные:
    ===========
    a: коэффициент на который входные данные будут умножаться
    если а - список, то это коэффициенты в полиномиальной зависимости
    так, а = [1,2,3] позволит сгенерировать зависимость вида 1*x+ 2*x^2 +3*x^3 
    b: коэффициент который будет добавлен к данным (постоянная прибавочка)
    f: функция которая будет применена к зависимости. Можно задать списком. Тогда это будут разные колонки
    N: количество точек данных
    x_max: максимальное значение данных
    noise_power: коэффициент ~ сила шума
    random_x: как будут распределены данные (линейно, или случайно)
    seed: фиксированный сид случайных чисел (для повторяемости)
    """

    np.random.seed(seed) # фиксируем случайный seed
    
    if random_x:# если мы хотим случайно распределить данные
        x = np.random.randint(x_max, size=N) # то x будет N случайных числе из диапазона от 0 до x_max
    else: # иначе
        x = np.linspace(0,x_max,N) # х это равномерно распределенные N чисел из диапазона от 0 до x_max
    
    y_true = np.array([]) # создаем пустой массив который будет "наполнять" зависимостями
    
    for f_ in np.append([], f): # если f - задана списком, то мы учтем все варианты
        y_true=np.append(y_true, true_fun(x, a, b, f_)) # применяем описанную выше функцию true_fun
    
   # y_true = y_true.reshape(-1,N).T
    y = y_true + noises(y_true.shape , noise_power) # добавляем шум

    return y, y_true, x #np.atleast_2d(x).T # возвращаем зашумленные значения зависимостей, зависимости без шума, и массив входных данных

a=lenfile('test')
for i in range(4):
    y, y_true, x = dataset(a = [1,2,-2], b = -1,
                       f = None,  N = 250,
                       x_max =50, random_x = True,
                       noise_power = np.random.random(1),
                       seed = 42)
    df=pd.DataFrame({"X": x, "Y":y})
    train=df[:201]
    test=df[201:]
    train.to_csv('train/train{}.csv'.format(i+a), index=False)
    test.to_csv('test/test{}.csv'.format(i+a), index=False)

test_df.to_csv('submission.csv', columns=['id', 'prognosis'], index=False)
d(log_dir="{}/{}".format(log_dir, time.time()))
